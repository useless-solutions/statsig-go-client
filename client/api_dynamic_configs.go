/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DynamicConfigsAPIService DynamicConfigsAPI service
type DynamicConfigsAPIService service

type ApiConsoleV1DynamicConfigControllerGenCreateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	dynamicConfigCreateDto *DynamicConfigCreateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenCreateRequest) DynamicConfigCreateDto(dynamicConfigCreateDto DynamicConfigCreateDto) ApiConsoleV1DynamicConfigControllerGenCreateRequest {
	r.dynamicConfigCreateDto = &dynamicConfigCreateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenCreateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenCreateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenCreateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenCreate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenCreateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenCreate Create Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1DynamicConfigControllerGenCreateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenCreate(ctx context.Context) ApiConsoleV1DynamicConfigControllerGenCreateRequest {
	return ApiConsoleV1DynamicConfigControllerGenCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenCreate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenCreateExecute(r ApiConsoleV1DynamicConfigControllerGenCreateRequest) (*ConsoleV1DynamicConfigControllerGenCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfigCreateDto == nil {
		return localVarReturnValue, nil, reportError("dynamicConfigCreateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.dynamicConfigCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConsoleV1DynamicConfigControllerGenCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ConsoleV1DynamicConfigControllerGenCreate403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenDisableRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenDisableRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenDisableRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenDisableRequest) Execute() (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenDisableExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenDisable Disable Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenDisableRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenDisable(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenDisableRequest {
	return ApiConsoleV1DynamicConfigControllerGenDisableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenDisableExecute(r ApiConsoleV1DynamicConfigControllerGenDisableRequest) (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenDisable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenEnableRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenEnableRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenEnableRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenEnableRequest) Execute() (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenEnableExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenEnable Enable Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenEnableRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenEnable(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenEnableRequest {
	return ApiConsoleV1DynamicConfigControllerGenEnableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenEnableExecute(r ApiConsoleV1DynamicConfigControllerGenEnableRequest) (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenEnable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	dynamicConfigFullUpdateDto *DynamicConfigFullUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest) DynamicConfigFullUpdateDto(dynamicConfigFullUpdateDto DynamicConfigFullUpdateDto) ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest {
	r.dynamicConfigFullUpdateDto = &dynamicConfigFullUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenFullUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenFullUpdateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenFullUpdate Fully Update Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenFullUpdate(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest {
	return ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenFullUpdate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenFullUpdateExecute(r ApiConsoleV1DynamicConfigControllerGenFullUpdateRequest) (*ConsoleV1DynamicConfigControllerGenFullUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenFullUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenFullUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfigFullUpdateDto == nil {
		return localVarReturnValue, nil, reportError("dynamicConfigFullUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.dynamicConfigFullUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConsoleV1DynamicConfigControllerGenCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ConsoleV1DynamicConfigControllerGenCreate403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenListRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	creatorName *string
	creatorID *string
	tags *[]string
	limit *int32
	page *int32
	xRespectReviewSettings *string
}

// Name of the creator.
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) CreatorName(creatorName string) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.creatorName = &creatorName
	return r
}

// ID of the user who created the entity.
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) CreatorID(creatorID string) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.creatorID = &creatorID
	return r
}

// Filter by tags
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) Tags(tags []string) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.tags = &tags
	return r
}

// Results per page
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) Limit(limit int32) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.limit = &limit
	return r
}

// Page number
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) Page(page int32) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.page = &page
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenListRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenListRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenListRequest) Execute() (*ConsoleV1DynamicConfigControllerGenList200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenListExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenList List Dynamic Configs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1DynamicConfigControllerGenListRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenList(ctx context.Context) ApiConsoleV1DynamicConfigControllerGenListRequest {
	return ApiConsoleV1DynamicConfigControllerGenListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenList200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenListExecute(r ApiConsoleV1DynamicConfigControllerGenListRequest) (*ConsoleV1DynamicConfigControllerGenList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.creatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorName", r.creatorName, "form", "")
	}
	if r.creatorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorID", r.creatorID, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenListVersionsRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenListVersionsRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenListVersionsRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenListVersionsRequest) Execute() (*ConsoleV1DynamicConfigControllerGenListVersions200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenListVersionsExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenListVersions List Dynamic Config Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenListVersionsRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenListVersions(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenListVersionsRequest {
	return ApiConsoleV1DynamicConfigControllerGenListVersionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenListVersions200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenListVersionsExecute(r ApiConsoleV1DynamicConfigControllerGenListVersionsRequest) (*ConsoleV1DynamicConfigControllerGenListVersions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenListVersions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenListVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	multiDynamicConfigRuleAddDto *MultiDynamicConfigRuleAddDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest) MultiDynamicConfigRuleAddDto(multiDynamicConfigRuleAddDto MultiDynamicConfigRuleAddDto) ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest {
	r.multiDynamicConfigRuleAddDto = &multiDynamicConfigRuleAddDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest) Execute() (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenMultiRuleAddExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenMultiRuleAdd Add Dynamic Config Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenMultiRuleAdd(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest {
	return ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenMultiRuleAddExecute(r ApiConsoleV1DynamicConfigControllerGenMultiRuleAddRequest) (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenMultiRuleAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiDynamicConfigRuleAddDto == nil {
		return localVarReturnValue, nil, reportError("multiDynamicConfigRuleAddDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.multiDynamicConfigRuleAddDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	multiRuleUpdateDto *MultiRuleUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest) MultiRuleUpdateDto(multiRuleUpdateDto MultiRuleUpdateDto) ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest {
	r.multiRuleUpdateDto = &multiRuleUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenMultiRuleUpdateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenMultiRuleUpdate Update List of Dynamic Config Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenMultiRuleUpdate(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest {
	return ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenMultiRuleUpdate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenMultiRuleUpdateExecute(r ApiConsoleV1DynamicConfigControllerGenMultiRuleUpdateRequest) (*ConsoleV1DynamicConfigControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenMultiRuleUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenMultiRuleUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiRuleUpdateDto == nil {
		return localVarReturnValue, nil, reportError("multiRuleUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.multiRuleUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	dynamicConfigPartialUpdateDto *DynamicConfigPartialUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest) DynamicConfigPartialUpdateDto(dynamicConfigPartialUpdateDto DynamicConfigPartialUpdateDto) ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest {
	r.dynamicConfigPartialUpdateDto = &dynamicConfigPartialUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenPartialUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenPartialUpdateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenPartialUpdate Partially Update Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenPartialUpdate(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest {
	return ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenPartialUpdate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenPartialUpdateExecute(r ApiConsoleV1DynamicConfigControllerGenPartialUpdateRequest) (*ConsoleV1DynamicConfigControllerGenPartialUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenPartialUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfigPartialUpdateDto == nil {
		return localVarReturnValue, nil, reportError("dynamicConfigPartialUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.dynamicConfigPartialUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenReadRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenReadRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenReadRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenReadRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRead200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenReadExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRead Get Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenReadRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRead(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenReadRequest {
	return ApiConsoleV1DynamicConfigControllerGenReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRead200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenReadExecute(r ApiConsoleV1DynamicConfigControllerGenReadRequest) (*ConsoleV1DynamicConfigControllerGenRead200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRead200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenReadRuleRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	ruleId string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenReadRuleRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenReadRuleRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenReadRuleRequest) Execute() (*ConsoleV1DynamicConfigControllerGenReadRule200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenReadRuleExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenReadRule Get Specific Dynamic Config Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Dynamic Config ID
 @param ruleId Rule ID
 @return ApiConsoleV1DynamicConfigControllerGenReadRuleRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenReadRule(ctx context.Context, id string, ruleId string) ApiConsoleV1DynamicConfigControllerGenReadRuleRequest {
	return ApiConsoleV1DynamicConfigControllerGenReadRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenReadRule200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenReadRuleExecute(r ApiConsoleV1DynamicConfigControllerGenReadRuleRequest) (*ConsoleV1DynamicConfigControllerGenReadRule200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenReadRule200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenReadRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenReadRulesRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenReadRulesRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenReadRulesRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenReadRulesRequest) Execute() (*ConsoleV1DynamicConfigControllerGenReadRules200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenReadRulesExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenReadRules Get Dynamic Config Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenReadRulesRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenReadRules(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenReadRulesRequest {
	return ApiConsoleV1DynamicConfigControllerGenReadRulesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenReadRules200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenReadRulesExecute(r ApiConsoleV1DynamicConfigControllerGenReadRulesRequest) (*ConsoleV1DynamicConfigControllerGenReadRules200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenReadRules200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenReadRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRemoveRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRemoveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRemoveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRemoveRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRemove200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRemoveExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRemove Delete Dynamic Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenRemoveRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRemove(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenRemoveRequest {
	return ApiConsoleV1DynamicConfigControllerGenRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRemove200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRemoveExecute(r ApiConsoleV1DynamicConfigControllerGenRemoveRequest) (*ConsoleV1DynamicConfigControllerGenRemove200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRemove200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRuleAddRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	dynamicConfigRuleAddDto *DynamicConfigRuleAddDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleAddRequest) DynamicConfigRuleAddDto(dynamicConfigRuleAddDto DynamicConfigRuleAddDto) ApiConsoleV1DynamicConfigControllerGenRuleAddRequest {
	r.dynamicConfigRuleAddDto = &dynamicConfigRuleAddDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRuleAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRuleAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleAddRequest) Execute() (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRuleAddExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRuleAdd Add Dynamic Config Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1DynamicConfigControllerGenRuleAddRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleAdd(ctx context.Context, id string) ApiConsoleV1DynamicConfigControllerGenRuleAddRequest {
	return ApiConsoleV1DynamicConfigControllerGenRuleAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleAddExecute(r ApiConsoleV1DynamicConfigControllerGenRuleAddRequest) (*ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRuleAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dynamicConfigRuleAddDto == nil {
		return localVarReturnValue, nil, reportError("dynamicConfigRuleAddDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.dynamicConfigRuleAddDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	ruleId string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRuleDelete200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRuleDeleteExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRuleDelete Delete Dynamic Config Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Dynamic Config ID
 @param ruleId Rule ID
 @return ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleDelete(ctx context.Context, id string, ruleId string) ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest {
	return ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRuleDelete200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleDeleteExecute(r ApiConsoleV1DynamicConfigControllerGenRuleDeleteRequest) (*ConsoleV1DynamicConfigControllerGenRuleDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRuleDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	ruleName string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRuleDelete200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRuleNameDeleteExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRuleNameDelete Delete Dynamic Config Rule By Name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Dynamic Config ID
 @param ruleName Rule Name
 @return ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleNameDelete(ctx context.Context, id string, ruleName string) ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest {
	return ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleName: ruleName,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRuleDelete200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleNameDeleteExecute(r ApiConsoleV1DynamicConfigControllerGenRuleNameDeleteRequest) (*ConsoleV1DynamicConfigControllerGenRuleDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRuleDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRuleNameDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule/name/{ruleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleName"+"}", url.PathEscape(parameterValueToString(r.ruleName, "ruleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	ruleName string
	ruleUpdateDto *RuleUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest) RuleUpdateDto(ruleUpdateDto RuleUpdateDto) ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest {
	r.ruleUpdateDto = &ruleUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRuleUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRuleNameUpdateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRuleNameUpdate Update Dynamic Config Rule By Name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Dynamic Config ID
 @param ruleName Rule Name
 @return ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleNameUpdate(ctx context.Context, id string, ruleName string) ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest {
	return ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleName: ruleName,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRuleUpdate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleNameUpdateExecute(r ApiConsoleV1DynamicConfigControllerGenRuleNameUpdateRequest) (*ConsoleV1DynamicConfigControllerGenRuleUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRuleUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRuleNameUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule/name/{ruleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleName"+"}", url.PathEscape(parameterValueToString(r.ruleName, "ruleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleUpdateDto == nil {
		return localVarReturnValue, nil, reportError("ruleUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ruleUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest struct {
	ctx context.Context
	ApiService *DynamicConfigsAPIService
	id string
	ruleId string
	ruleUpdateDto *RuleUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest) RuleUpdateDto(ruleUpdateDto RuleUpdateDto) ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest {
	r.ruleUpdateDto = &ruleUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest) Execute() (*ConsoleV1DynamicConfigControllerGenRuleUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1DynamicConfigControllerGenRuleUpdateExecute(r)
}

/*
ConsoleV1DynamicConfigControllerGenRuleUpdate Update Dynamic Config Rule By Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Dynamic Config ID
 @param ruleId Rule ID
 @return ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest
*/
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleUpdate(ctx context.Context, id string, ruleId string) ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest {
	return ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return ConsoleV1DynamicConfigControllerGenRuleUpdate200Response
func (a *DynamicConfigsAPIService) ConsoleV1DynamicConfigControllerGenRuleUpdateExecute(r ApiConsoleV1DynamicConfigControllerGenRuleUpdateRequest) (*ConsoleV1DynamicConfigControllerGenRuleUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1DynamicConfigControllerGenRuleUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicConfigsAPIService.ConsoleV1DynamicConfigControllerGenRuleUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/dynamic_configs/{id}/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleUpdateDto == nil {
		return localVarReturnValue, nil, reportError("ruleUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ruleUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
