/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// GatesAPIService GatesAPI service
type GatesAPIService service

type ApiConsoleV1GateOverridesControllerGenAddRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	updateOverridesContractDto *UpdateOverridesContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GateOverridesControllerGenAddRequest) UpdateOverridesContractDto(updateOverridesContractDto UpdateOverridesContractDto) ApiConsoleV1GateOverridesControllerGenAddRequest {
	r.updateOverridesContractDto = &updateOverridesContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GateOverridesControllerGenAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GateOverridesControllerGenAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GateOverridesControllerGenAddRequest) Execute() (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GateOverridesControllerGenAddExecute(r)
}

/*
ConsoleV1GateOverridesControllerGenAdd Add Gate Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GateOverridesControllerGenAddRequest
*/
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenAdd(ctx context.Context, id string) ApiConsoleV1GateOverridesControllerGenAddRequest {
	return ApiConsoleV1GateOverridesControllerGenAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GateOverridesControllerGenUpdate201Response
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenAddExecute(r ApiConsoleV1GateOverridesControllerGenAddRequest) (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GateOverridesControllerGenUpdate201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GateOverridesControllerGenAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOverridesContractDto == nil {
		return localVarReturnValue, nil, reportError("updateOverridesContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.updateOverridesContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GateOverridesControllerGenReadRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GateOverridesControllerGenReadRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GateOverridesControllerGenReadRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GateOverridesControllerGenReadRequest) Execute() (*ConsoleV1GateOverridesControllerGenRead201Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GateOverridesControllerGenReadExecute(r)
}

/*
ConsoleV1GateOverridesControllerGenRead Get Gate Override

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GateOverridesControllerGenReadRequest
*/
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenRead(ctx context.Context, id string) ApiConsoleV1GateOverridesControllerGenReadRequest {
	return ApiConsoleV1GateOverridesControllerGenReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GateOverridesControllerGenRead201Response
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenReadExecute(r ApiConsoleV1GateOverridesControllerGenReadRequest) (*ConsoleV1GateOverridesControllerGenRead201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GateOverridesControllerGenRead201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GateOverridesControllerGenRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GateOverridesControllerGenRemoveRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GateOverridesControllerGenRemoveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GateOverridesControllerGenRemoveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GateOverridesControllerGenRemoveRequest) Execute() (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GateOverridesControllerGenRemoveExecute(r)
}

/*
ConsoleV1GateOverridesControllerGenRemove Delete Gate Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GateOverridesControllerGenRemoveRequest
*/
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenRemove(ctx context.Context, id string) ApiConsoleV1GateOverridesControllerGenRemoveRequest {
	return ApiConsoleV1GateOverridesControllerGenRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GateOverridesControllerGenUpdate201Response
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenRemoveExecute(r ApiConsoleV1GateOverridesControllerGenRemoveRequest) (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GateOverridesControllerGenUpdate201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GateOverridesControllerGenRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GateOverridesControllerGenUpdateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	updateOverridesContractDto *UpdateOverridesContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GateOverridesControllerGenUpdateRequest) UpdateOverridesContractDto(updateOverridesContractDto UpdateOverridesContractDto) ApiConsoleV1GateOverridesControllerGenUpdateRequest {
	r.updateOverridesContractDto = &updateOverridesContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GateOverridesControllerGenUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GateOverridesControllerGenUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GateOverridesControllerGenUpdateRequest) Execute() (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GateOverridesControllerGenUpdateExecute(r)
}

/*
ConsoleV1GateOverridesControllerGenUpdate Update Gate Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GateOverridesControllerGenUpdateRequest
*/
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenUpdate(ctx context.Context, id string) ApiConsoleV1GateOverridesControllerGenUpdateRequest {
	return ApiConsoleV1GateOverridesControllerGenUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GateOverridesControllerGenUpdate201Response
func (a *GatesAPIService) ConsoleV1GateOverridesControllerGenUpdateExecute(r ApiConsoleV1GateOverridesControllerGenUpdateRequest) (*ConsoleV1GateOverridesControllerGenUpdate201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GateOverridesControllerGenUpdate201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GateOverridesControllerGenUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOverridesContractDto == nil {
		return localVarReturnValue, nil, reportError("updateOverridesContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.updateOverridesContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenArchiveRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	archiveSchemaDto *ArchiveSchemaDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenArchiveRequest) ArchiveSchemaDto(archiveSchemaDto ArchiveSchemaDto) ApiConsoleV1GatesControllerGenArchiveRequest {
	r.archiveSchemaDto = &archiveSchemaDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenArchiveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenArchiveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenArchiveRequest) Execute() (*ConsoleV1GatesControllerGenArchive200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenArchiveExecute(r)
}

/*
ConsoleV1GatesControllerGenArchive Archive Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenArchiveRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenArchive(ctx context.Context, id string) ApiConsoleV1GatesControllerGenArchiveRequest {
	return ApiConsoleV1GatesControllerGenArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenArchive200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenArchiveExecute(r ApiConsoleV1GatesControllerGenArchiveRequest) (*ConsoleV1GatesControllerGenArchive200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenArchive200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archiveSchemaDto == nil {
		return localVarReturnValue, nil, reportError("archiveSchemaDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.archiveSchemaDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenCreateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	gateCreateDto *GateCreateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenCreateRequest) GateCreateDto(gateCreateDto GateCreateDto) ApiConsoleV1GatesControllerGenCreateRequest {
	r.gateCreateDto = &gateCreateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenCreateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenCreateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenCreateRequest) Execute() (*ConsoleV1GatesControllerGenCreate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenCreateExecute(r)
}

/*
ConsoleV1GatesControllerGenCreate Create Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1GatesControllerGenCreateRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenCreate(ctx context.Context) ApiConsoleV1GatesControllerGenCreateRequest {
	return ApiConsoleV1GatesControllerGenCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenCreate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenCreateExecute(r ApiConsoleV1GatesControllerGenCreateRequest) (*ConsoleV1GatesControllerGenCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateCreateDto == nil {
		return localVarReturnValue, nil, reportError("gateCreateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.gateCreateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenDisableRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenDisableRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenDisableRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenDisableRequest) Execute() (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenDisableExecute(r)
}

/*
ConsoleV1GatesControllerGenDisable Disable Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenDisableRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenDisable(ctx context.Context, id string) ApiConsoleV1GatesControllerGenDisableRequest {
	return ApiConsoleV1GatesControllerGenDisableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenLaunch200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenDisableExecute(r ApiConsoleV1GatesControllerGenDisableRequest) (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenLaunch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenDisable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenEnableRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenEnableRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenEnableRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenEnableRequest) Execute() (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenEnableExecute(r)
}

/*
ConsoleV1GatesControllerGenEnable Enable Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenEnableRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenEnable(ctx context.Context, id string) ApiConsoleV1GatesControllerGenEnableRequest {
	return ApiConsoleV1GatesControllerGenEnableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenLaunch200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenEnableExecute(r ApiConsoleV1GatesControllerGenEnableRequest) (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenLaunch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenEnable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenFullUpdateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	gateFullUpdateDto *GateFullUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenFullUpdateRequest) GateFullUpdateDto(gateFullUpdateDto GateFullUpdateDto) ApiConsoleV1GatesControllerGenFullUpdateRequest {
	r.gateFullUpdateDto = &gateFullUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenFullUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenFullUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenFullUpdateRequest) Execute() (*ConsoleV1GatesControllerGenFullUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenFullUpdateExecute(r)
}

/*
ConsoleV1GatesControllerGenFullUpdate Fully Update Gates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenFullUpdateRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenFullUpdate(ctx context.Context, id string) ApiConsoleV1GatesControllerGenFullUpdateRequest {
	return ApiConsoleV1GatesControllerGenFullUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenFullUpdate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenFullUpdateExecute(r ApiConsoleV1GatesControllerGenFullUpdateRequest) (*ConsoleV1GatesControllerGenFullUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenFullUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenFullUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateFullUpdateDto == nil {
		return localVarReturnValue, nil, reportError("gateFullUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.gateFullUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenLaunchRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenLaunchRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenLaunchRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenLaunchRequest) Execute() (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenLaunchExecute(r)
}

/*
ConsoleV1GatesControllerGenLaunch Launch Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenLaunchRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenLaunch(ctx context.Context, id string) ApiConsoleV1GatesControllerGenLaunchRequest {
	return ApiConsoleV1GatesControllerGenLaunchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenLaunch200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenLaunchExecute(r ApiConsoleV1GatesControllerGenLaunchRequest) (*ConsoleV1GatesControllerGenLaunch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenLaunch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenLaunch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/launch"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenListRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	idType *[]string
	type_ *string
	typeReason *string
	passRate *interface{}
	rolloutRate *interface{}
	creatorName *string
	creatorID *string
	tags *[]string
	limit *int32
	page *int32
	xRespectReviewSettings *string
}

// Filter by idType
func (r ApiConsoleV1GatesControllerGenListRequest) IdType(idType []string) ApiConsoleV1GatesControllerGenListRequest {
	r.idType = &idType
	return r
}

// Filter by type
func (r ApiConsoleV1GatesControllerGenListRequest) Type_(type_ string) ApiConsoleV1GatesControllerGenListRequest {
	r.type_ = &type_
	return r
}

// Filter by typeReason
func (r ApiConsoleV1GatesControllerGenListRequest) TypeReason(typeReason string) ApiConsoleV1GatesControllerGenListRequest {
	r.typeReason = &typeReason
	return r
}

// Filter by pass rate of the gates, as determined by a sampling of overall true/false values returned: 0, 100, or INBETWEEN (pass rate greater than zero but less than 100)
func (r ApiConsoleV1GatesControllerGenListRequest) PassRate(passRate interface{}) ApiConsoleV1GatesControllerGenListRequest {
	r.passRate = &passRate
	return r
}

// Filter by rollout rate of the gates: 0 (all rules are set to pass 0%), 100 (all rules pass 100% including an \&quot;everyone\&quot; catch all rule), or INBETWEEN (at least one rule has a pass rate greater than 0 but less than 100)
func (r ApiConsoleV1GatesControllerGenListRequest) RolloutRate(rolloutRate interface{}) ApiConsoleV1GatesControllerGenListRequest {
	r.rolloutRate = &rolloutRate
	return r
}

// Name of the creator.
func (r ApiConsoleV1GatesControllerGenListRequest) CreatorName(creatorName string) ApiConsoleV1GatesControllerGenListRequest {
	r.creatorName = &creatorName
	return r
}

// ID of the user who created the entity.
func (r ApiConsoleV1GatesControllerGenListRequest) CreatorID(creatorID string) ApiConsoleV1GatesControllerGenListRequest {
	r.creatorID = &creatorID
	return r
}

// Filter by tags
func (r ApiConsoleV1GatesControllerGenListRequest) Tags(tags []string) ApiConsoleV1GatesControllerGenListRequest {
	r.tags = &tags
	return r
}

// Results per page
func (r ApiConsoleV1GatesControllerGenListRequest) Limit(limit int32) ApiConsoleV1GatesControllerGenListRequest {
	r.limit = &limit
	return r
}

// Page number
func (r ApiConsoleV1GatesControllerGenListRequest) Page(page int32) ApiConsoleV1GatesControllerGenListRequest {
	r.page = &page
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenListRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenListRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenListRequest) Execute() (*ConsoleV1GatesControllerGenList200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenListExecute(r)
}

/*
ConsoleV1GatesControllerGenList List Gates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1GatesControllerGenListRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenList(ctx context.Context) ApiConsoleV1GatesControllerGenListRequest {
	return ApiConsoleV1GatesControllerGenListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenList200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenListExecute(r ApiConsoleV1GatesControllerGenListRequest) (*ConsoleV1GatesControllerGenList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idType != nil {
		t := *r.idType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "idType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "idType", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.typeReason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeReason", r.typeReason, "form", "")
	}
	if r.passRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "passRate", r.passRate, "form", "")
	}
	if r.rolloutRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rolloutRate", r.rolloutRate, "form", "")
	}
	if r.creatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorName", r.creatorName, "form", "")
	}
	if r.creatorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorID", r.creatorID, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ConsoleV1AlertsControllerGenList403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenLoadPulseRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	echidnaGateLoadPulseQueryDto *EchidnaGateLoadPulseQueryDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenLoadPulseRequest) EchidnaGateLoadPulseQueryDto(echidnaGateLoadPulseQueryDto EchidnaGateLoadPulseQueryDto) ApiConsoleV1GatesControllerGenLoadPulseRequest {
	r.echidnaGateLoadPulseQueryDto = &echidnaGateLoadPulseQueryDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenLoadPulseRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenLoadPulseRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenLoadPulseRequest) Execute() (*ConsoleV1GatesControllerGenLoadPulse200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenLoadPulseExecute(r)
}

/*
ConsoleV1GatesControllerGenLoadPulse Load Pulse Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenLoadPulseRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenLoadPulse(ctx context.Context, id string) ApiConsoleV1GatesControllerGenLoadPulseRequest {
	return ApiConsoleV1GatesControllerGenLoadPulseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenLoadPulse200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenLoadPulseExecute(r ApiConsoleV1GatesControllerGenLoadPulseRequest) (*ConsoleV1GatesControllerGenLoadPulse200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenLoadPulse200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenLoadPulse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/load_pulse"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.echidnaGateLoadPulseQueryDto == nil {
		return localVarReturnValue, nil, reportError("echidnaGateLoadPulseQueryDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.echidnaGateLoadPulseQueryDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenMultiRuleAddRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	multiRuleDto *MultiRuleDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenMultiRuleAddRequest) MultiRuleDto(multiRuleDto MultiRuleDto) ApiConsoleV1GatesControllerGenMultiRuleAddRequest {
	r.multiRuleDto = &multiRuleDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenMultiRuleAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenMultiRuleAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenMultiRuleAddRequest) Execute() (*ConsoleV1GatesControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenMultiRuleAddExecute(r)
}

/*
ConsoleV1GatesControllerGenMultiRuleAdd Add Multiple Gate Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenMultiRuleAddRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenMultiRuleAdd(ctx context.Context, id string) ApiConsoleV1GatesControllerGenMultiRuleAddRequest {
	return ApiConsoleV1GatesControllerGenMultiRuleAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenMultiRuleAdd200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenMultiRuleAddExecute(r ApiConsoleV1GatesControllerGenMultiRuleAddRequest) (*ConsoleV1GatesControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenMultiRuleAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiRuleDto == nil {
		return localVarReturnValue, nil, reportError("multiRuleDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.multiRuleDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	multiRuleUpdateDto *MultiRuleUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest) MultiRuleUpdateDto(multiRuleUpdateDto MultiRuleUpdateDto) ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest {
	r.multiRuleUpdateDto = &multiRuleUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest) Execute() (*ConsoleV1GatesControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenMultiRuleUpdateExecute(r)
}

/*
ConsoleV1GatesControllerGenMultiRuleUpdate Update list of Gate Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenMultiRuleUpdate(ctx context.Context, id string) ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest {
	return ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenMultiRuleUpdate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenMultiRuleUpdateExecute(r ApiConsoleV1GatesControllerGenMultiRuleUpdateRequest) (*ConsoleV1GatesControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenMultiRuleUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenMultiRuleUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiRuleUpdateDto == nil {
		return localVarReturnValue, nil, reportError("multiRuleUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.multiRuleUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenPartialUpdateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	gatePartialUpdateDto *GatePartialUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenPartialUpdateRequest) GatePartialUpdateDto(gatePartialUpdateDto GatePartialUpdateDto) ApiConsoleV1GatesControllerGenPartialUpdateRequest {
	r.gatePartialUpdateDto = &gatePartialUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenPartialUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenPartialUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenPartialUpdateRequest) Execute() (*ConsoleV1GatesControllerGenPartialUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenPartialUpdateExecute(r)
}

/*
ConsoleV1GatesControllerGenPartialUpdate Partially Update Gates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenPartialUpdateRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenPartialUpdate(ctx context.Context, id string) ApiConsoleV1GatesControllerGenPartialUpdateRequest {
	return ApiConsoleV1GatesControllerGenPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenPartialUpdate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenPartialUpdateExecute(r ApiConsoleV1GatesControllerGenPartialUpdateRequest) (*ConsoleV1GatesControllerGenPartialUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenPartialUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatePartialUpdateDto == nil {
		return localVarReturnValue, nil, reportError("gatePartialUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.gatePartialUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	ruleID string
	limit *int32
	page *int32
	xRespectReviewSettings *string
}

// Results per page
func (r ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest) Limit(limit int32) ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest {
	r.limit = &limit
	return r
}

// Page number
func (r ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest) Page(page int32) ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest {
	r.page = &page
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest) Execute() (*ConsoleV1GatesControllerGenPulseLoadHistory200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenPulseLoadHistoryExecute(r)
}

/*
ConsoleV1GatesControllerGenPulseLoadHistory Pulse Load History (Warehouse Native)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Gate ID
 @param ruleID Rule ID
 @return ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenPulseLoadHistory(ctx context.Context, id string, ruleID string) ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest {
	return ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleID: ruleID,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenPulseLoadHistory200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenPulseLoadHistoryExecute(r ApiConsoleV1GatesControllerGenPulseLoadHistoryRequest) (*ConsoleV1GatesControllerGenPulseLoadHistory200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenPulseLoadHistory200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenPulseLoadHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules/{ruleID}/pulse_load_history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleID"+"}", url.PathEscape(parameterValueToString(r.ruleID, "ruleID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenPulseResultsRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	ruleID string
	cuped *string
	xRespectReviewSettings *string
}

// Whether to apply CUPED. Allowed values are \&quot;true\&quot; or \&quot;false\&quot;.
func (r ApiConsoleV1GatesControllerGenPulseResultsRequest) Cuped(cuped string) ApiConsoleV1GatesControllerGenPulseResultsRequest {
	r.cuped = &cuped
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenPulseResultsRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenPulseResultsRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenPulseResultsRequest) Execute() (*ConsoleV1GatesControllerGenPulseResults200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenPulseResultsExecute(r)
}

/*
ConsoleV1GatesControllerGenPulseResults Retrieve Pulse Results (Beta)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Gate ID
 @param ruleID Rule ID
 @return ApiConsoleV1GatesControllerGenPulseResultsRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenPulseResults(ctx context.Context, id string, ruleID string) ApiConsoleV1GatesControllerGenPulseResultsRequest {
	return ApiConsoleV1GatesControllerGenPulseResultsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleID: ruleID,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenPulseResults200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenPulseResultsExecute(r ApiConsoleV1GatesControllerGenPulseResultsRequest) (*ConsoleV1GatesControllerGenPulseResults200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenPulseResults200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenPulseResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules/{ruleID}/pulse_results"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleID"+"}", url.PathEscape(parameterValueToString(r.ruleID, "ruleID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cuped == nil {
		return localVarReturnValue, nil, reportError("cuped is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cuped", r.cuped, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenReadRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenReadRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenReadRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenReadRequest) Execute() (*ConsoleV1GatesControllerGenRead200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenReadExecute(r)
}

/*
ConsoleV1GatesControllerGenRead Read Gate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenReadRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenRead(ctx context.Context, id string) ApiConsoleV1GatesControllerGenReadRequest {
	return ApiConsoleV1GatesControllerGenReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenRead200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenReadExecute(r ApiConsoleV1GatesControllerGenReadRequest) (*ConsoleV1GatesControllerGenRead200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenRead200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenReadRulesRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenReadRulesRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenReadRulesRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenReadRulesRequest) Execute() (*ConsoleV1GatesControllerGenReadRules200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenReadRulesExecute(r)
}

/*
ConsoleV1GatesControllerGenReadRules Read Gate Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenReadRulesRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenReadRules(ctx context.Context, id string) ApiConsoleV1GatesControllerGenReadRulesRequest {
	return ApiConsoleV1GatesControllerGenReadRulesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenReadRules200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenReadRulesExecute(r ApiConsoleV1GatesControllerGenReadRulesRequest) (*ConsoleV1GatesControllerGenReadRules200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenReadRules200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenReadRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenRemoveRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenRemoveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenRemoveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenRemoveRequest) Execute() (*ConsoleV1GatesControllerGenRemove200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenRemoveExecute(r)
}

/*
ConsoleV1GatesControllerGenRemove Delete Gates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenRemoveRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenRemove(ctx context.Context, id string) ApiConsoleV1GatesControllerGenRemoveRequest {
	return ApiConsoleV1GatesControllerGenRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenRemove200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenRemoveExecute(r ApiConsoleV1GatesControllerGenRemoveRequest) (*ConsoleV1GatesControllerGenRemove200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenRemove200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenRuleAddRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	ruleDto *RuleDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenRuleAddRequest) RuleDto(ruleDto RuleDto) ApiConsoleV1GatesControllerGenRuleAddRequest {
	r.ruleDto = &ruleDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenRuleAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenRuleAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenRuleAddRequest) Execute() (*ConsoleV1GatesControllerGenMultiRuleAdd200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenRuleAddExecute(r)
}

/*
ConsoleV1GatesControllerGenRuleAdd Add Gate Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1GatesControllerGenRuleAddRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleAdd(ctx context.Context, id string) ApiConsoleV1GatesControllerGenRuleAddRequest {
	return ApiConsoleV1GatesControllerGenRuleAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenMultiRuleAdd200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleAddExecute(r ApiConsoleV1GatesControllerGenRuleAddRequest) (*ConsoleV1GatesControllerGenMultiRuleAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenMultiRuleAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenRuleAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleDto == nil {
		return localVarReturnValue, nil, reportError("ruleDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ruleDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenRuleDeleteRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	ruleID string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenRuleDeleteRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenRuleDeleteRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenRuleDeleteRequest) Execute() (*ConsoleV1GatesControllerGenPartialUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenRuleDeleteExecute(r)
}

/*
ConsoleV1GatesControllerGenRuleDelete Delete Gate Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Gate ID
 @param ruleID Rule ID
 @return ApiConsoleV1GatesControllerGenRuleDeleteRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleDelete(ctx context.Context, id string, ruleID string) ApiConsoleV1GatesControllerGenRuleDeleteRequest {
	return ApiConsoleV1GatesControllerGenRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleID: ruleID,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenPartialUpdate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleDeleteExecute(r ApiConsoleV1GatesControllerGenRuleDeleteRequest) (*ConsoleV1GatesControllerGenPartialUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenPartialUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenRuleDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules/{ruleID}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleID"+"}", url.PathEscape(parameterValueToString(r.ruleID, "ruleID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1GatesControllerGenRuleUpdateRequest struct {
	ctx context.Context
	ApiService *GatesAPIService
	id string
	ruleID string
	ruleUpdateDto *RuleUpdateDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1GatesControllerGenRuleUpdateRequest) RuleUpdateDto(ruleUpdateDto RuleUpdateDto) ApiConsoleV1GatesControllerGenRuleUpdateRequest {
	r.ruleUpdateDto = &ruleUpdateDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1GatesControllerGenRuleUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1GatesControllerGenRuleUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1GatesControllerGenRuleUpdateRequest) Execute() (*ConsoleV1GatesControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1GatesControllerGenRuleUpdateExecute(r)
}

/*
ConsoleV1GatesControllerGenRuleUpdate Update Gate Rules

Update all given rules. It does NOT create or delete if you add more rules and remove rules in the rules object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Gate ID
 @param ruleID Rule ID
 @return ApiConsoleV1GatesControllerGenRuleUpdateRequest
*/
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleUpdate(ctx context.Context, id string, ruleID string) ApiConsoleV1GatesControllerGenRuleUpdateRequest {
	return ApiConsoleV1GatesControllerGenRuleUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		ruleID: ruleID,
	}
}

// Execute executes the request
//  @return ConsoleV1GatesControllerGenMultiRuleUpdate200Response
func (a *GatesAPIService) ConsoleV1GatesControllerGenRuleUpdateExecute(r ApiConsoleV1GatesControllerGenRuleUpdateRequest) (*ConsoleV1GatesControllerGenMultiRuleUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1GatesControllerGenMultiRuleUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GatesAPIService.ConsoleV1GatesControllerGenRuleUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/gates/{id}/rules/{ruleID}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleID"+"}", url.PathEscape(parameterValueToString(r.ruleID, "ruleID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleUpdateDto == nil {
		return localVarReturnValue, nil, reportError("ruleUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ruleUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
