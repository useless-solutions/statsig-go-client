/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// HoldoutsAPIService HoldoutsAPI service
type HoldoutsAPIService service

type ApiConsoleV1HoldoutOverridesControllerGenAddRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	updateOverridesContractDto *UpdateOverridesContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutOverridesControllerGenAddRequest) UpdateOverridesContractDto(updateOverridesContractDto UpdateOverridesContractDto) ApiConsoleV1HoldoutOverridesControllerGenAddRequest {
	r.updateOverridesContractDto = &updateOverridesContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutOverridesControllerGenAddRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutOverridesControllerGenAddRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutOverridesControllerGenAddRequest) Execute() (*ConsoleV1HoldoutOverridesControllerGenUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutOverridesControllerGenAddExecute(r)
}

/*
ConsoleV1HoldoutOverridesControllerGenAdd Add Holdout Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutOverridesControllerGenAddRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenAdd(ctx context.Context, id string) ApiConsoleV1HoldoutOverridesControllerGenAddRequest {
	return ApiConsoleV1HoldoutOverridesControllerGenAddRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutOverridesControllerGenUpdate200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenAddExecute(r ApiConsoleV1HoldoutOverridesControllerGenAddRequest) (*ConsoleV1HoldoutOverridesControllerGenUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutOverridesControllerGenUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutOverridesControllerGenAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOverridesContractDto == nil {
		return localVarReturnValue, nil, reportError("updateOverridesContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.updateOverridesContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutOverridesControllerGenReadRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutOverridesControllerGenReadRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutOverridesControllerGenReadRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutOverridesControllerGenReadRequest) Execute() (*ConsoleV1HoldoutOverridesControllerGenRead200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutOverridesControllerGenReadExecute(r)
}

/*
ConsoleV1HoldoutOverridesControllerGenRead Read Holdout Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutOverridesControllerGenReadRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenRead(ctx context.Context, id string) ApiConsoleV1HoldoutOverridesControllerGenReadRequest {
	return ApiConsoleV1HoldoutOverridesControllerGenReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutOverridesControllerGenRead200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenReadExecute(r ApiConsoleV1HoldoutOverridesControllerGenReadRequest) (*ConsoleV1HoldoutOverridesControllerGenRead200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutOverridesControllerGenRead200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutOverridesControllerGenRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	updateOverridesContractDto *UpdateOverridesContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest) UpdateOverridesContractDto(updateOverridesContractDto UpdateOverridesContractDto) ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest {
	r.updateOverridesContractDto = &updateOverridesContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest) Execute() (*ConsoleV1HoldoutOverridesControllerGenRemove200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutOverridesControllerGenRemoveExecute(r)
}

/*
ConsoleV1HoldoutOverridesControllerGenRemove Remove Holdout Overrides

Remove selected ids from an id list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenRemove(ctx context.Context, id string) ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest {
	return ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutOverridesControllerGenRemove200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenRemoveExecute(r ApiConsoleV1HoldoutOverridesControllerGenRemoveRequest) (*ConsoleV1HoldoutOverridesControllerGenRemove200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutOverridesControllerGenRemove200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutOverridesControllerGenRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOverridesContractDto == nil {
		return localVarReturnValue, nil, reportError("updateOverridesContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.updateOverridesContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	updateOverridesContractDto *UpdateOverridesContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest) UpdateOverridesContractDto(updateOverridesContractDto UpdateOverridesContractDto) ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest {
	r.updateOverridesContractDto = &updateOverridesContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest) Execute() (*ConsoleV1HoldoutOverridesControllerGenUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutOverridesControllerGenUpdateExecute(r)
}

/*
ConsoleV1HoldoutOverridesControllerGenUpdate Update Holdout Overrides

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenUpdate(ctx context.Context, id string) ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest {
	return ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutOverridesControllerGenUpdate200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutOverridesControllerGenUpdateExecute(r ApiConsoleV1HoldoutOverridesControllerGenUpdateRequest) (*ConsoleV1HoldoutOverridesControllerGenUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutOverridesControllerGenUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutOverridesControllerGenUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}/overrides"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOverridesContractDto == nil {
		return localVarReturnValue, nil, reportError("updateOverridesContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.updateOverridesContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenCreateRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	holdoutCreateContractDto *HoldoutCreateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutsControllerGenCreateRequest) HoldoutCreateContractDto(holdoutCreateContractDto HoldoutCreateContractDto) ApiConsoleV1HoldoutsControllerGenCreateRequest {
	r.holdoutCreateContractDto = &holdoutCreateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenCreateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenCreateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenCreateRequest) Execute() (*ConsoleV1HoldoutsControllerGenCreate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenCreateExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenCreate Create holdout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1HoldoutsControllerGenCreateRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenCreate(ctx context.Context) ApiConsoleV1HoldoutsControllerGenCreateRequest {
	return ApiConsoleV1HoldoutsControllerGenCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenCreate200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenCreateExecute(r ApiConsoleV1HoldoutsControllerGenCreateRequest) (*ConsoleV1HoldoutsControllerGenCreate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenCreate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.holdoutCreateContractDto == nil {
		return localVarReturnValue, nil, reportError("holdoutCreateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.holdoutCreateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConsoleV1DynamicConfigControllerGenCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenFullUpdateRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	holdoutFullUpdateContractDto *HoldoutFullUpdateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutsControllerGenFullUpdateRequest) HoldoutFullUpdateContractDto(holdoutFullUpdateContractDto HoldoutFullUpdateContractDto) ApiConsoleV1HoldoutsControllerGenFullUpdateRequest {
	r.holdoutFullUpdateContractDto = &holdoutFullUpdateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenFullUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenFullUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenFullUpdateRequest) Execute() (*ConsoleV1HoldoutsControllerGenFullUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenFullUpdateExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenFullUpdate Update holdout by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutsControllerGenFullUpdateRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenFullUpdate(ctx context.Context, id string) ApiConsoleV1HoldoutsControllerGenFullUpdateRequest {
	return ApiConsoleV1HoldoutsControllerGenFullUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenFullUpdate200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenFullUpdateExecute(r ApiConsoleV1HoldoutsControllerGenFullUpdateRequest) (*ConsoleV1HoldoutsControllerGenFullUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenFullUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenFullUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.holdoutFullUpdateContractDto == nil {
		return localVarReturnValue, nil, reportError("holdoutFullUpdateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.holdoutFullUpdateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConsoleV1DynamicConfigControllerGenCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenListRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	creatorName *string
	creatorID *string
	tags *[]string
	limit *int32
	page *int32
	xRespectReviewSettings *string
}

// Name of the creator.
func (r ApiConsoleV1HoldoutsControllerGenListRequest) CreatorName(creatorName string) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.creatorName = &creatorName
	return r
}

// ID of the user who created the entity.
func (r ApiConsoleV1HoldoutsControllerGenListRequest) CreatorID(creatorID string) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.creatorID = &creatorID
	return r
}

// Filter by tags
func (r ApiConsoleV1HoldoutsControllerGenListRequest) Tags(tags []string) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.tags = &tags
	return r
}

// Results per page
func (r ApiConsoleV1HoldoutsControllerGenListRequest) Limit(limit int32) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.limit = &limit
	return r
}

// Page number
func (r ApiConsoleV1HoldoutsControllerGenListRequest) Page(page int32) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.page = &page
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenListRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenListRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenListRequest) Execute() (*ConsoleV1HoldoutsControllerGenList200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenListExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenList List Holdouts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1HoldoutsControllerGenListRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenList(ctx context.Context) ApiConsoleV1HoldoutsControllerGenListRequest {
	return ApiConsoleV1HoldoutsControllerGenListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenList200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenListExecute(r ApiConsoleV1HoldoutsControllerGenListRequest) (*ConsoleV1HoldoutsControllerGenList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.creatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorName", r.creatorName, "form", "")
	}
	if r.creatorID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorID", r.creatorID, "form", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	holdoutPartialUpdateContractDto *HoldoutPartialUpdateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest) HoldoutPartialUpdateContractDto(holdoutPartialUpdateContractDto HoldoutPartialUpdateContractDto) ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest {
	r.holdoutPartialUpdateContractDto = &holdoutPartialUpdateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest) Execute() (*ConsoleV1HoldoutsControllerGenPartialUpdate200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenPartialUpdateExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenPartialUpdate Patch holdout by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenPartialUpdate(ctx context.Context, id string) ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest {
	return ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenPartialUpdate200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenPartialUpdateExecute(r ApiConsoleV1HoldoutsControllerGenPartialUpdateRequest) (*ConsoleV1HoldoutsControllerGenPartialUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenPartialUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.holdoutPartialUpdateContractDto == nil {
		return localVarReturnValue, nil, reportError("holdoutPartialUpdateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.holdoutPartialUpdateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenReadRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenReadRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenReadRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenReadRequest) Execute() (*ConsoleV1HoldoutsControllerGenRead200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenReadExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenRead Get holdout by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutsControllerGenReadRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenRead(ctx context.Context, id string) ApiConsoleV1HoldoutsControllerGenReadRequest {
	return ApiConsoleV1HoldoutsControllerGenReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenRead200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenReadExecute(r ApiConsoleV1HoldoutsControllerGenReadRequest) (*ConsoleV1HoldoutsControllerGenRead200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenRead200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1HoldoutsControllerGenRemoveRequest struct {
	ctx context.Context
	ApiService *HoldoutsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1HoldoutsControllerGenRemoveRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1HoldoutsControllerGenRemoveRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1HoldoutsControllerGenRemoveRequest) Execute() (*ConsoleV1HoldoutsControllerGenRemove200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1HoldoutsControllerGenRemoveExecute(r)
}

/*
ConsoleV1HoldoutsControllerGenRemove Delete holdout by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1HoldoutsControllerGenRemoveRequest
*/
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenRemove(ctx context.Context, id string) ApiConsoleV1HoldoutsControllerGenRemoveRequest {
	return ApiConsoleV1HoldoutsControllerGenRemoveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1HoldoutsControllerGenRemove200Response
func (a *HoldoutsAPIService) ConsoleV1HoldoutsControllerGenRemoveExecute(r ApiConsoleV1HoldoutsControllerGenRemoveRequest) (*ConsoleV1HoldoutsControllerGenRemove200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1HoldoutsControllerGenRemove200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HoldoutsAPIService.ConsoleV1HoldoutsControllerGenRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/holdouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
