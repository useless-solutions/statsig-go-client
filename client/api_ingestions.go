/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IngestionsAPIService IngestionsAPI service
type IngestionsAPIService service

type ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	ingestionCreateDatabricksConnectionContractDto *IngestionCreateDatabricksConnectionContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest) IngestionCreateDatabricksConnectionContractDto(ingestionCreateDatabricksConnectionContractDto IngestionCreateDatabricksConnectionContractDto) ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest {
	r.ingestionCreateDatabricksConnectionContractDto = &ingestionCreateDatabricksConnectionContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest) Execute() (*ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksExecute(r)
}

/*
ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks Create Ingestion Databricks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks(ctx context.Context) ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest {
	return ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks200Response
func (a *IngestionsAPIService) ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksExecute(r ApiConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricksRequest) (*ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionConnectionControllerGenCreateIngestionDatabricks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/connection/databricks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingestionCreateDatabricksConnectionContractDto == nil {
		return localVarReturnValue, nil, reportError("ingestionCreateDatabricksConnectionContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ingestionCreateDatabricksConnectionContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenBackfillIngestionRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	ingestionBackfillContractDto *IngestionBackfillContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenBackfillIngestionRequest) IngestionBackfillContractDto(ingestionBackfillContractDto IngestionBackfillContractDto) ApiConsoleV1IngestionControllerGenBackfillIngestionRequest {
	r.ingestionBackfillContractDto = &ingestionBackfillContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenBackfillIngestionRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenBackfillIngestionRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenBackfillIngestionRequest) Execute() (*ConsoleV1IngestionControllerGenBackfillIngestion200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenBackfillIngestionExecute(r)
}

/*
ConsoleV1IngestionControllerGenBackfillIngestion Backfill Ingestion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenBackfillIngestionRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenBackfillIngestion(ctx context.Context) ApiConsoleV1IngestionControllerGenBackfillIngestionRequest {
	return ApiConsoleV1IngestionControllerGenBackfillIngestionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenBackfillIngestion200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenBackfillIngestionExecute(r ApiConsoleV1IngestionControllerGenBackfillIngestionRequest) (*ConsoleV1IngestionControllerGenBackfillIngestion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenBackfillIngestion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenBackfillIngestion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/backfill"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingestionBackfillContractDto == nil {
		return localVarReturnValue, nil, reportError("ingestionBackfillContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ingestionBackfillContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConsoleV1DynamicConfigControllerGenCreate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	ingestionSourceCreateContractDto *IngestionSourceCreateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest) IngestionSourceCreateContractDto(ingestionSourceCreateContractDto IngestionSourceCreateContractDto) ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest {
	r.ingestionSourceCreateContractDto = &ingestionSourceCreateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest) Execute() (*ConsoleV1IngestionControllerGenCreateIngestionSource200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenCreateIngestionSourceExecute(r)
}

/*
ConsoleV1IngestionControllerGenCreateIngestionSource Create Ingestion Source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenCreateIngestionSource(ctx context.Context) ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest {
	return ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenCreateIngestionSource200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenCreateIngestionSourceExecute(r ApiConsoleV1IngestionControllerGenCreateIngestionSourceRequest) (*ConsoleV1IngestionControllerGenCreateIngestionSource200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenCreateIngestionSource200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenCreateIngestionSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingestionSourceCreateContractDto == nil {
		return localVarReturnValue, nil, reportError("ingestionSourceCreateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ingestionSourceCreateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	type_ *string
	dataset *string
	sourceName *string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) Type_(type_ string) ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest {
	r.type_ = &type_
	return r
}

func (r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) Dataset(dataset string) ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest {
	r.dataset = &dataset
	return r
}

func (r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) SourceName(sourceName string) ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest {
	r.sourceName = &sourceName
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) Execute() (*ConsoleV1IngestionControllerGenDeleteIngestionSource200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenDeleteIngestionSourceExecute(r)
}

/*
ConsoleV1IngestionControllerGenDeleteIngestionSource Delete Ingestion Source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenDeleteIngestionSource(ctx context.Context) ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest {
	return ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenDeleteIngestionSource200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenDeleteIngestionSourceExecute(r ApiConsoleV1IngestionControllerGenDeleteIngestionSourceRequest) (*ConsoleV1IngestionControllerGenDeleteIngestionSource200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenDeleteIngestionSource200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenDeleteIngestionSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_name", r.sourceName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenIngestionRunRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	id string
	xRespectReviewSettings *string
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenIngestionRunRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenIngestionRunRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionRunRequest) Execute() (*ConsoleV1IngestionControllerGenIngestionRun200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenIngestionRunExecute(r)
}

/*
ConsoleV1IngestionControllerGenIngestionRun Read Ingestion Run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiConsoleV1IngestionControllerGenIngestionRunRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionRun(ctx context.Context, id string) ApiConsoleV1IngestionControllerGenIngestionRunRequest {
	return ApiConsoleV1IngestionControllerGenIngestionRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenIngestionRun200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionRunExecute(r ApiConsoleV1IngestionControllerGenIngestionRunRequest) (*ConsoleV1IngestionControllerGenIngestionRun200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenIngestionRun200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenIngestionRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/runs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConsoleV1DynamicConfigControllerGenList404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenIngestionRunsRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	page *interface{}
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenIngestionRunsRequest) Page(page interface{}) ApiConsoleV1IngestionControllerGenIngestionRunsRequest {
	r.page = &page
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenIngestionRunsRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenIngestionRunsRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionRunsRequest) Execute() (*ConsoleV1IngestionControllerGenIngestionRuns200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenIngestionRunsExecute(r)
}

/*
ConsoleV1IngestionControllerGenIngestionRuns List Ingestion Runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenIngestionRunsRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionRuns(ctx context.Context) ApiConsoleV1IngestionControllerGenIngestionRunsRequest {
	return ApiConsoleV1IngestionControllerGenIngestionRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenIngestionRuns200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionRunsExecute(r ApiConsoleV1IngestionControllerGenIngestionRunsRequest) (*ConsoleV1IngestionControllerGenIngestionRuns200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenIngestionRuns200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenIngestionRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenIngestionStatusListRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	startDate *string
	endDate *string
	source *string
	dataset *string
	status *string
	statuses *[]string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) StartDate(startDate string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.startDate = &startDate
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) EndDate(endDate string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.endDate = &endDate
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) Source(source string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.source = &source
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) Dataset(dataset string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.dataset = &dataset
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) Status(status string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.status = &status
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) Statuses(statuses []string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.statuses = &statuses
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) Execute() (*ConsoleV1IngestionControllerGenIngestionStatusList200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenIngestionStatusListExecute(r)
}

/*
ConsoleV1IngestionControllerGenIngestionStatusList List Ingestions Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenIngestionStatusListRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionStatusList(ctx context.Context) ApiConsoleV1IngestionControllerGenIngestionStatusListRequest {
	return ApiConsoleV1IngestionControllerGenIngestionStatusListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenIngestionStatusList200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenIngestionStatusListExecute(r ApiConsoleV1IngestionControllerGenIngestionStatusListRequest) (*ConsoleV1IngestionControllerGenIngestionStatusList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenIngestionStatusList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenIngestionStatusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.dataset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ConsoleV1DynamicConfigControllerGenCreate401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenReadIngestionRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	type_ *string
	dataset *string
	sourceName *string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionRequest) Type_(type_ string) ApiConsoleV1IngestionControllerGenReadIngestionRequest {
	r.type_ = &type_
	return r
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionRequest) Dataset(dataset string) ApiConsoleV1IngestionControllerGenReadIngestionRequest {
	r.dataset = &dataset
	return r
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionRequest) SourceName(sourceName string) ApiConsoleV1IngestionControllerGenReadIngestionRequest {
	r.sourceName = &sourceName
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenReadIngestionRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenReadIngestionRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionRequest) Execute() (*ConsoleV1IngestionControllerGenReadIngestion200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenReadIngestionExecute(r)
}

/*
ConsoleV1IngestionControllerGenReadIngestion Read Ingestion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenReadIngestionRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenReadIngestion(ctx context.Context) ApiConsoleV1IngestionControllerGenReadIngestionRequest {
	return ApiConsoleV1IngestionControllerGenReadIngestionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenReadIngestion200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenReadIngestionExecute(r ApiConsoleV1IngestionControllerGenReadIngestionRequest) (*ConsoleV1IngestionControllerGenReadIngestion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenReadIngestion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenReadIngestion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_name", r.sourceName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	dataset *string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest) Dataset(dataset string) ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest {
	r.dataset = &dataset
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest) Execute() (*ConsoleV1IngestionControllerGenReadIngestionSchedule200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenReadIngestionScheduleExecute(r)
}

/*
ConsoleV1IngestionControllerGenReadIngestionSchedule Read Ingestion Schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenReadIngestionSchedule(ctx context.Context) ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest {
	return ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenReadIngestionSchedule200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenReadIngestionScheduleExecute(r ApiConsoleV1IngestionControllerGenReadIngestionScheduleRequest) (*ConsoleV1IngestionControllerGenReadIngestionSchedule200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenReadIngestionSchedule200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenReadIngestionSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenUpdateIngestionRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	ingestionUpdateContractDto *IngestionUpdateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenUpdateIngestionRequest) IngestionUpdateContractDto(ingestionUpdateContractDto IngestionUpdateContractDto) ApiConsoleV1IngestionControllerGenUpdateIngestionRequest {
	r.ingestionUpdateContractDto = &ingestionUpdateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenUpdateIngestionRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenUpdateIngestionRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenUpdateIngestionRequest) Execute() (*ConsoleV1IngestionControllerGenUpdateIngestion200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenUpdateIngestionExecute(r)
}

/*
ConsoleV1IngestionControllerGenUpdateIngestion Update Ingestion Source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenUpdateIngestionRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenUpdateIngestion(ctx context.Context) ApiConsoleV1IngestionControllerGenUpdateIngestionRequest {
	return ApiConsoleV1IngestionControllerGenUpdateIngestionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenUpdateIngestion200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenUpdateIngestionExecute(r ApiConsoleV1IngestionControllerGenUpdateIngestionRequest) (*ConsoleV1IngestionControllerGenUpdateIngestion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenUpdateIngestion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenUpdateIngestion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingestionUpdateContractDto == nil {
		return localVarReturnValue, nil, reportError("ingestionUpdateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ingestionUpdateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	ingestionScheduleUpdateContractDto *IngestionScheduleUpdateContractDto
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest) IngestionScheduleUpdateContractDto(ingestionScheduleUpdateContractDto IngestionScheduleUpdateContractDto) ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest {
	r.ingestionScheduleUpdateContractDto = &ingestionScheduleUpdateContractDto
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest) Execute() (*ConsoleV1IngestionControllerGenUpdateIngestionSchedule200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionControllerGenUpdateIngestionScheduleExecute(r)
}

/*
ConsoleV1IngestionControllerGenUpdateIngestionSchedule Update Ingestion Schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenUpdateIngestionSchedule(ctx context.Context) ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest {
	return ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionControllerGenUpdateIngestionSchedule200Response
func (a *IngestionsAPIService) ConsoleV1IngestionControllerGenUpdateIngestionScheduleExecute(r ApiConsoleV1IngestionControllerGenUpdateIngestionScheduleRequest) (*ConsoleV1IngestionControllerGenUpdateIngestionSchedule200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionControllerGenUpdateIngestionSchedule200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionControllerGenUpdateIngestionSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingestionScheduleUpdateContractDto == nil {
		return localVarReturnValue, nil, reportError("ingestionScheduleUpdateContractDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	// body params
	localVarPostBody = r.ingestionScheduleUpdateContractDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	startDate *string
	endDate *string
	sourceName *string
	eventName *string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) StartDate(startDate string) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	r.startDate = &startDate
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) EndDate(endDate string) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	r.endDate = &endDate
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) SourceName(sourceName string) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	r.sourceName = &sourceName
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) EventName(eventName string) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	r.eventName = &eventName
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) Execute() (*ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerExecute(r)
}

/*
ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger Get Ingestion Event Delta Ledger

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger(ctx context.Context) ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest {
	return ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger200Response
func (a *IngestionsAPIService) ConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerExecute(r ApiConsoleV1IngestionEventsControllerGenIngestionDeltaLedgerRequest) (*ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionEventsControllerGenIngestionDeltaLedger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/events/delta"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_name", r.sourceName, "form", "")
	}
	if r.eventName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_name", r.eventName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest struct {
	ctx context.Context
	ApiService *IngestionsAPIService
	startDate *string
	endDate *string
	sourceName *string
	eventName *string
	xRespectReviewSettings *string
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) StartDate(startDate string) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	r.startDate = &startDate
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) EndDate(endDate string) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	r.endDate = &endDate
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) SourceName(sourceName string) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	r.sourceName = &sourceName
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) EventName(eventName string) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	r.eventName = &eventName
	return r
}

// Optional header to respect review settings for mutation endpoints.
func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) XRespectReviewSettings(xRespectReviewSettings string) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	r.xRespectReviewSettings = &xRespectReviewSettings
	return r
}

func (r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) Execute() (*ConsoleV1IngestionEventsControllerGenIngestionEventCount200Response, *http.Response, error) {
	return r.ApiService.ConsoleV1IngestionEventsControllerGenIngestionEventCountExecute(r)
}

/*
ConsoleV1IngestionEventsControllerGenIngestionEventCount Get Ingestion Event Count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest
*/
func (a *IngestionsAPIService) ConsoleV1IngestionEventsControllerGenIngestionEventCount(ctx context.Context) ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest {
	return ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsoleV1IngestionEventsControllerGenIngestionEventCount200Response
func (a *IngestionsAPIService) ConsoleV1IngestionEventsControllerGenIngestionEventCountExecute(r ApiConsoleV1IngestionEventsControllerGenIngestionEventCountRequest) (*ConsoleV1IngestionEventsControllerGenIngestionEventCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsoleV1IngestionEventsControllerGenIngestionEventCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngestionsAPIService.ConsoleV1IngestionEventsControllerGenIngestionEventCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/console/v1/ingestion/events/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_name", r.sourceName, "form", "")
	}
	if r.eventName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_name", r.eventName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRespectReviewSettings != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-respect-review-settings", r.xRespectReviewSettings, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["STATSIG-API-KEY"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["STATSIG-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
