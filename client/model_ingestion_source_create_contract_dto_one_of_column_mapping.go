/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the IngestionSourceCreateContractDtoOneOfColumnMapping type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &IngestionSourceCreateContractDtoOneOfColumnMapping{}

// IngestionSourceCreateContractDtoOneOfColumnMapping struct for IngestionSourceCreateContractDtoOneOfColumnMapping
type IngestionSourceCreateContractDtoOneOfColumnMapping struct {
	// The unique user identifier this metric is for. This might not necessarily be a user_id - it could be a custom_id of some kind. Make sure this is in the same format as your logged unit_ids.
	UnitId string `json:"unit_id"`
	// The id_type the unit_id represents. Must be valid id_type. Default Statsig types are user_id/stable_id, but you may have generated custom id_types. Make sure this matches (case sensitive) a customID in your project, or you won’t get experiment results.
	IdType string `json:"id_type"`
	// Date of the daily metric, ISO formatted (ex. 2024-10-23). We’ll load custom metrics to whatever date you use here.
	Dateid string `json:"dateid"`
	// String format. Not null. Length < 128 characters.
	MetricName string `json:"metric_name"`
	// Numeric value for the metric. This OR both of numerator and denominator need to be provided.
	MetricValue *string `json:"metric_value,omitempty"`
	// Required for ratio metrics. If present along with a denominator in any record, the metric will be treated as ratio and only calculated for users with non-null denominators
	Numerator *string `json:"numerator,omitempty"`
	// Required for ratio metrics. If present along with a numerator in any record, the metric will be treated as ratio and only calculated for users with non-null numerators.
	Denominator *string `json:"denominator,omitempty"`
}

type _IngestionSourceCreateContractDtoOneOfColumnMapping IngestionSourceCreateContractDtoOneOfColumnMapping

// NewIngestionSourceCreateContractDtoOneOfColumnMapping instantiates a new IngestionSourceCreateContractDtoOneOfColumnMapping object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewIngestionSourceCreateContractDtoOneOfColumnMapping(unitId string, idType string, dateid string, metricName string) *IngestionSourceCreateContractDtoOneOfColumnMapping {
	this := IngestionSourceCreateContractDtoOneOfColumnMapping{}
	this.UnitId = unitId
	this.IdType = idType
	this.Dateid = dateid
	this.MetricName = metricName
	var metricValue string = "null"
	this.MetricValue = &metricValue
	var numerator string = "null"
	this.Numerator = &numerator
	var denominator string = "null"
	this.Denominator = &denominator
	return &this
}

// NewIngestionSourceCreateContractDtoOneOfColumnMappingWithDefaults instantiates a new IngestionSourceCreateContractDtoOneOfColumnMapping object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewIngestionSourceCreateContractDtoOneOfColumnMappingWithDefaults() *IngestionSourceCreateContractDtoOneOfColumnMapping {
	this := IngestionSourceCreateContractDtoOneOfColumnMapping{}
	var metricValue string = "null"
	this.MetricValue = &metricValue
	var numerator string = "null"
	this.Numerator = &numerator
	var denominator string = "null"
	this.Denominator = &denominator
	return &this
}

// GetUnitId returns the UnitId field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetUnitId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.UnitId
}

// GetUnitIdOk returns a tuple with the UnitId field value
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetUnitIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.UnitId, true
}

// SetUnitId sets field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetUnitId(v string) {
	o.UnitId = v
}

// GetIdType returns the IdType field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetIdType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.IdType
}

// GetIdTypeOk returns a tuple with the IdType field value
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetIdTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.IdType, true
}

// SetIdType sets field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetIdType(v string) {
	o.IdType = v
}

// GetDateid returns the Dateid field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetDateid() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Dateid
}

// GetDateidOk returns a tuple with the Dateid field value
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetDateidOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Dateid, true
}

// SetDateid sets field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetDateid(v string) {
	o.Dateid = v
}

// GetMetricName returns the MetricName field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetMetricName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.MetricName
}

// GetMetricNameOk returns a tuple with the MetricName field value
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetMetricNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.MetricName, true
}

// SetMetricName sets field value
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetMetricName(v string) {
	o.MetricName = v
}

// GetMetricValue returns the MetricValue field value if set, zero value otherwise.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetMetricValue() string {
	if o == nil || IsNil(o.MetricValue) {
		var ret string
		return ret
	}
	return *o.MetricValue
}

// GetMetricValueOk returns a tuple with the MetricValue field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetMetricValueOk() (*string, bool) {
	if o == nil || IsNil(o.MetricValue) {
		return nil, false
	}
	return o.MetricValue, true
}

// HasMetricValue returns a boolean if a field has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) HasMetricValue() bool {
	if o != nil && !IsNil(o.MetricValue) {
		return true
	}

	return false
}

// SetMetricValue gets a reference to the given string and assigns it to the MetricValue field.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetMetricValue(v string) {
	o.MetricValue = &v
}

// GetNumerator returns the Numerator field value if set, zero value otherwise.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetNumerator() string {
	if o == nil || IsNil(o.Numerator) {
		var ret string
		return ret
	}
	return *o.Numerator
}

// GetNumeratorOk returns a tuple with the Numerator field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetNumeratorOk() (*string, bool) {
	if o == nil || IsNil(o.Numerator) {
		return nil, false
	}
	return o.Numerator, true
}

// HasNumerator returns a boolean if a field has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) HasNumerator() bool {
	if o != nil && !IsNil(o.Numerator) {
		return true
	}

	return false
}

// SetNumerator gets a reference to the given string and assigns it to the Numerator field.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetNumerator(v string) {
	o.Numerator = &v
}

// GetDenominator returns the Denominator field value if set, zero value otherwise.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetDenominator() string {
	if o == nil || IsNil(o.Denominator) {
		var ret string
		return ret
	}
	return *o.Denominator
}

// GetDenominatorOk returns a tuple with the Denominator field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) GetDenominatorOk() (*string, bool) {
	if o == nil || IsNil(o.Denominator) {
		return nil, false
	}
	return o.Denominator, true
}

// HasDenominator returns a boolean if a field has been set.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) HasDenominator() bool {
	if o != nil && !IsNil(o.Denominator) {
		return true
	}

	return false
}

// SetDenominator gets a reference to the given string and assigns it to the Denominator field.
func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) SetDenominator(v string) {
	o.Denominator = &v
}

func (o IngestionSourceCreateContractDtoOneOfColumnMapping) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o IngestionSourceCreateContractDtoOneOfColumnMapping) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["unit_id"] = o.UnitId
	toSerialize["id_type"] = o.IdType
	toSerialize["dateid"] = o.Dateid
	toSerialize["metric_name"] = o.MetricName
	if !IsNil(o.MetricValue) {
		toSerialize["metric_value"] = o.MetricValue
	}
	if !IsNil(o.Numerator) {
		toSerialize["numerator"] = o.Numerator
	}
	if !IsNil(o.Denominator) {
		toSerialize["denominator"] = o.Denominator
	}
	return toSerialize, nil
}

func (o *IngestionSourceCreateContractDtoOneOfColumnMapping) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"unit_id",
		"id_type",
		"dateid",
		"metric_name",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varIngestionSourceCreateContractDtoOneOfColumnMapping := _IngestionSourceCreateContractDtoOneOfColumnMapping{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varIngestionSourceCreateContractDtoOneOfColumnMapping)

	if err != nil {
		return err
	}

	*o = IngestionSourceCreateContractDtoOneOfColumnMapping(varIngestionSourceCreateContractDtoOneOfColumnMapping)

	return err
}

type NullableIngestionSourceCreateContractDtoOneOfColumnMapping struct {
	value *IngestionSourceCreateContractDtoOneOfColumnMapping
	isSet bool
}

func (v NullableIngestionSourceCreateContractDtoOneOfColumnMapping) Get() *IngestionSourceCreateContractDtoOneOfColumnMapping {
	return v.value
}

func (v *NullableIngestionSourceCreateContractDtoOneOfColumnMapping) Set(val *IngestionSourceCreateContractDtoOneOfColumnMapping) {
	v.value = val
	v.isSet = true
}

func (v NullableIngestionSourceCreateContractDtoOneOfColumnMapping) IsSet() bool {
	return v.isSet
}

func (v *NullableIngestionSourceCreateContractDtoOneOfColumnMapping) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableIngestionSourceCreateContractDtoOneOfColumnMapping(val *IngestionSourceCreateContractDtoOneOfColumnMapping) *NullableIngestionSourceCreateContractDtoOneOfColumnMapping {
	return &NullableIngestionSourceCreateContractDtoOneOfColumnMapping{value: val, isSet: true}
}

func (v NullableIngestionSourceCreateContractDtoOneOfColumnMapping) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableIngestionSourceCreateContractDtoOneOfColumnMapping) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


