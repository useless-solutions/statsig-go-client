/*
Console API

       The \"Console API\" is the CRUD API for performing the actions offered on console.statsig.com without needing to go through the web UI.       If you have any feature requests, drop on in to our [slack channel](https://www.statsig.com/slack) and let us know.       <br /><br />       <b>Authorization</b>       <br />       All requests must include the **STATSIG-API-KEY** field in the header. The value should be a **Console API Key** which can be created in the Project Settings on [console.statsig.com/api_keys](https://console.statsig.com/api_keys)       <br /><br />       <b>Rate Limiting</b>       <br />       Requests to the Console API are limited to <code>~ 100reqs / 10secs and ~ 900reqs / 15 mins</code>.       <br /><br />       <b>Keyboard Search</b>       <br />       Use <code>Ctrl/Cmd + K</code> to search for specific endpoints.       

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the MetricValueDto type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &MetricValueDto{}

// MetricValueDto struct for MetricValueDto
type MetricValueDto struct {
	Value float32 `json:"value"`
	UnitType string `json:"unitType"`
	Numerator *float32 `json:"numerator,omitempty"`
	Denominator *float32 `json:"denominator,omitempty"`
	InputRows *float32 `json:"inputRows,omitempty"`
	MetricName string `json:"metricName"`
	MetricType string `json:"metricType"`
}

type _MetricValueDto MetricValueDto

// NewMetricValueDto instantiates a new MetricValueDto object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewMetricValueDto(value float32, unitType string, metricName string, metricType string) *MetricValueDto {
	this := MetricValueDto{}
	this.Value = value
	this.UnitType = unitType
	this.MetricName = metricName
	this.MetricType = metricType
	return &this
}

// NewMetricValueDtoWithDefaults instantiates a new MetricValueDto object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewMetricValueDtoWithDefaults() *MetricValueDto {
	this := MetricValueDto{}
	return &this
}

// GetValue returns the Value field value
func (o *MetricValueDto) GetValue() float32 {
	if o == nil {
		var ret float32
		return ret
	}

	return o.Value
}

// GetValueOk returns a tuple with the Value field value
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetValueOk() (*float32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Value, true
}

// SetValue sets field value
func (o *MetricValueDto) SetValue(v float32) {
	o.Value = v
}

// GetUnitType returns the UnitType field value
func (o *MetricValueDto) GetUnitType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.UnitType
}

// GetUnitTypeOk returns a tuple with the UnitType field value
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetUnitTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.UnitType, true
}

// SetUnitType sets field value
func (o *MetricValueDto) SetUnitType(v string) {
	o.UnitType = v
}

// GetNumerator returns the Numerator field value if set, zero value otherwise.
func (o *MetricValueDto) GetNumerator() float32 {
	if o == nil || IsNil(o.Numerator) {
		var ret float32
		return ret
	}
	return *o.Numerator
}

// GetNumeratorOk returns a tuple with the Numerator field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetNumeratorOk() (*float32, bool) {
	if o == nil || IsNil(o.Numerator) {
		return nil, false
	}
	return o.Numerator, true
}

// HasNumerator returns a boolean if a field has been set.
func (o *MetricValueDto) HasNumerator() bool {
	if o != nil && !IsNil(o.Numerator) {
		return true
	}

	return false
}

// SetNumerator gets a reference to the given float32 and assigns it to the Numerator field.
func (o *MetricValueDto) SetNumerator(v float32) {
	o.Numerator = &v
}

// GetDenominator returns the Denominator field value if set, zero value otherwise.
func (o *MetricValueDto) GetDenominator() float32 {
	if o == nil || IsNil(o.Denominator) {
		var ret float32
		return ret
	}
	return *o.Denominator
}

// GetDenominatorOk returns a tuple with the Denominator field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetDenominatorOk() (*float32, bool) {
	if o == nil || IsNil(o.Denominator) {
		return nil, false
	}
	return o.Denominator, true
}

// HasDenominator returns a boolean if a field has been set.
func (o *MetricValueDto) HasDenominator() bool {
	if o != nil && !IsNil(o.Denominator) {
		return true
	}

	return false
}

// SetDenominator gets a reference to the given float32 and assigns it to the Denominator field.
func (o *MetricValueDto) SetDenominator(v float32) {
	o.Denominator = &v
}

// GetInputRows returns the InputRows field value if set, zero value otherwise.
func (o *MetricValueDto) GetInputRows() float32 {
	if o == nil || IsNil(o.InputRows) {
		var ret float32
		return ret
	}
	return *o.InputRows
}

// GetInputRowsOk returns a tuple with the InputRows field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetInputRowsOk() (*float32, bool) {
	if o == nil || IsNil(o.InputRows) {
		return nil, false
	}
	return o.InputRows, true
}

// HasInputRows returns a boolean if a field has been set.
func (o *MetricValueDto) HasInputRows() bool {
	if o != nil && !IsNil(o.InputRows) {
		return true
	}

	return false
}

// SetInputRows gets a reference to the given float32 and assigns it to the InputRows field.
func (o *MetricValueDto) SetInputRows(v float32) {
	o.InputRows = &v
}

// GetMetricName returns the MetricName field value
func (o *MetricValueDto) GetMetricName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.MetricName
}

// GetMetricNameOk returns a tuple with the MetricName field value
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetMetricNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.MetricName, true
}

// SetMetricName sets field value
func (o *MetricValueDto) SetMetricName(v string) {
	o.MetricName = v
}

// GetMetricType returns the MetricType field value
func (o *MetricValueDto) GetMetricType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.MetricType
}

// GetMetricTypeOk returns a tuple with the MetricType field value
// and a boolean to check if the value has been set.
func (o *MetricValueDto) GetMetricTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.MetricType, true
}

// SetMetricType sets field value
func (o *MetricValueDto) SetMetricType(v string) {
	o.MetricType = v
}

func (o MetricValueDto) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o MetricValueDto) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["value"] = o.Value
	toSerialize["unitType"] = o.UnitType
	if !IsNil(o.Numerator) {
		toSerialize["numerator"] = o.Numerator
	}
	if !IsNil(o.Denominator) {
		toSerialize["denominator"] = o.Denominator
	}
	if !IsNil(o.InputRows) {
		toSerialize["inputRows"] = o.InputRows
	}
	toSerialize["metricName"] = o.MetricName
	toSerialize["metricType"] = o.MetricType
	return toSerialize, nil
}

func (o *MetricValueDto) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"value",
		"unitType",
		"metricName",
		"metricType",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varMetricValueDto := _MetricValueDto{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varMetricValueDto)

	if err != nil {
		return err
	}

	*o = MetricValueDto(varMetricValueDto)

	return err
}

type NullableMetricValueDto struct {
	value *MetricValueDto
	isSet bool
}

func (v NullableMetricValueDto) Get() *MetricValueDto {
	return v.value
}

func (v *NullableMetricValueDto) Set(val *MetricValueDto) {
	v.value = val
	v.isSet = true
}

func (v NullableMetricValueDto) IsSet() bool {
	return v.isSet
}

func (v *NullableMetricValueDto) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableMetricValueDto(val *MetricValueDto) *NullableMetricValueDto {
	return &NullableMetricValueDto{value: val, isSet: true}
}

func (v NullableMetricValueDto) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableMetricValueDto) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


